/*
 * This file was generated automatically by xsubpp version 1.9507 from the 
 * contents of UDUNITS.xs. Do not edit this file, edit UDUNITS.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "UDUNITS.xs"
#include <stdio.h>	/* for diagnostics */
#include <stdlib.h>
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "udunits.h"

extern utUnit	*utNew();

static int
not_here(s)
char *s;
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(name, arg)
char *name;
int arg;
{
    errno = 0;
    switch (*name) {
    case 'A':
	break;
    case 'B':
	break;
    case 'C':
	break;
    case 'D':
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	break;
    case 'H':
	break;
    case 'I':
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	break;
    case 'N':
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	break;
    case 'R':
	break;
    case 'S':
	break;
    case 'T':
	break;
    case 'U':
	if (strEQ(name, "EALLOC"))
#ifdef UT_EALLOC
	    return UT_EALLOC;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ECONVERT"))
#ifdef UT_ECONVERT
	    return UT_ECONVERT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "EINVALID"))
#ifdef UT_EINVALID
	    return UT_EINVALID;
#else
	    goto not_there;
#endif
	if (strEQ(name, "EIO"))
#ifdef UT_EIO
	    return UT_EIO;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ENOFILE"))
#ifdef UT_ENOFILE
	    return UT_ENOFILE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ENOINIT"))
#ifdef UT_ENOINIT
	    return UT_ENOINIT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ENOROOM"))
#ifdef UT_ENOROOM
	    return UT_ENOROOM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ENOTTIME"))
#ifdef UT_ENOTTIME
	    return UT_ENOTTIME;
#else
	    goto not_there;
#endif
	if (strEQ(name, "EOF"))
#ifdef UT_EOF
	    return UT_EOF;
#else
	    goto not_there;
#endif
	if (strEQ(name, "ESYNTAX"))
#ifdef UT_ESYNTAX
	    return UT_ESYNTAX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "EUNKNOWN"))
#ifdef UT_EUNKNOWN
	    return UT_EUNKNOWN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MAXNUM_BASE_QUANTITIES"))
#ifdef UT_MAXNUM_BASE_QUANTITIES
	    return UT_MAXNUM_BASE_QUANTITIES;
#else
	    goto not_there;
#endif
	if (strEQ(name, "NAMELEN"))
#ifdef UT_NAMELEN
	    return UT_NAMELEN;
#else
	    goto not_there;
#endif
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}


#line 176 "UDUNITS.c"
XS(XS_UDUNITS_constant)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: UDUNITS::constant(name,arg)");
    {
	char *	name = (char *)SvPV(ST(0),PL_na);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;

	RETVAL = constant(name, arg);
	ST(0) = sv_newmortal();
	sv_setnv(ST(0), (double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_UDUNITS_init)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: UDUNITS::init(path)");
    {
	char *	path = (char *)SvPV(ST(0),PL_na);
	int	RETVAL;
#line 179 "UDUNITS.xs"
    {
	RETVAL = utInit(path);
    }
#line 206 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_UDUNITS_term)
{
    dXSARGS;
    if (items != 0)
	croak("Usage: UDUNITS::term()");
    {
#line 189 "UDUNITS.xs"
    {
	utTerm();
    }
#line 223 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_UDUNITS_new)
{
    dXSARGS;
    if (items != 0)
	croak("Usage: UDUNITS::new()");
    {
	utUnit *	RETVAL;
#line 197 "UDUNITS.xs"
    {
	RETVAL = utNew();

	if (RETVAL == 0)
	    croak("Couldn't allocate %lu bytes for new unit structure",
		  sizeof(utUnit));
    }
#line 243 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "utUnitPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_UDUNITS_scan)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: UDUNITS::scan(spec)");
    {
	char *	spec = (char *)SvPV(ST(0),PL_na);
#line 212 "UDUNITS.xs"
    {
	int	status;
	utUnit	*unit = utNew();

	if (unit == 0)
	    croak("Couldn't allocate %lu bytes for new unit structure",
		  sizeof(utUnit));

	ST(0) = sv_newmortal();

	status = utScan(spec, unit);

	if (status == UT_ENOINIT)
	    croak("units module not initialized");
	else if (status == 0)
	    sv_setref_pv(ST(0), "utUnitPtr", (void*)unit);
    }
#line 275 "UDUNITS.c"
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_istime)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::istime(unit)");
    {
	utUnit *	unit;
	int	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 238 "UDUNITS.xs"
    {
	RETVAL = utIsTime(unit);
    }
#line 299 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_hasorigin)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::hasorigin(unit)");
    {
	utUnit *	unit;
	int	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 249 "UDUNITS.xs"
    {
	RETVAL = utHasOrigin(unit);
    }
#line 325 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_clear)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::clear(unit)");
    {
	utUnit *	unit;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 260 "UDUNITS.xs"
    {
	(void) utClear(unit);
    }
#line 350 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_dup)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::dup(source)");
    {
	utUnit *	source;
	utUnit *	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    source = (utUnit *) tmp;
	}
	else
	    croak("source is not of type utUnitPtr");
#line 269 "UDUNITS.xs"
    {
	utUnit	*dest = utNew();

	if (dest == 0)
	    croak("Couldn't allocate %lu bytes for new unit structure",
		  sizeof(utUnit));

	RETVAL = utCopy(source, dest);
    }
#line 380 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "utUnitPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_shift)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: utUnitPtr::shift(unit, amount)");
    {
	utUnit *	unit;
	double	amount = (double)SvNV(ST(1));

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 287 "UDUNITS.xs"
    {
	(void) utShift(unit, amount, unit);
    }
#line 406 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_scale)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: utUnitPtr::scale(unit, coefficient)");
    {
	utUnit *	unit;
	double	coefficient = (double)SvNV(ST(1));

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 297 "UDUNITS.xs"
    {
	(void) utScale(unit, coefficient, unit);
    }
#line 430 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_multiply)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: utUnitPtr::multiply(unit, otherunit)");
    {
	utUnit *	unit;
	utUnit *	otherunit;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");

	if (sv_derived_from(ST(1), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    otherunit = (utUnit *) tmp;
	}
	else
	    croak("otherunit is not of type utUnitPtr");
#line 307 "UDUNITS.xs"
    {
	(void) utMultiply(unit, otherunit, unit);
    }
#line 461 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_invert)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::invert(unit)");
    {
	utUnit *	unit;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 316 "UDUNITS.xs"
    {
	(void) utInvert(unit, unit);
    }
#line 484 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_divide)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: utUnitPtr::divide(unit, divisor)");
    {
	utUnit *	unit;
	utUnit *	divisor;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");

	if (sv_derived_from(ST(1), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    divisor = (utUnit *) tmp;
	}
	else
	    croak("divisor is not of type utUnitPtr");
#line 326 "UDUNITS.xs"
    {
	(void) utDivide(unit, divisor, unit);
    }
#line 515 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_raise)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: utUnitPtr::raise(unit, power)");
    {
	utUnit *	unit;
	int	power = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 336 "UDUNITS.xs"
    {
	(void) utRaise(unit, power, unit);
    }
#line 539 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_utUnitPtr_print)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::print(unit)");
    {
	utUnit *	unit;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 345 "UDUNITS.xs"
    {
	char	*staticbuf;

	(void) utPrint(unit, &staticbuf);
	ST(0) = sv_newmortal();
	sv_setpv((SV*)ST(0), staticbuf);
    }
#line 566 "UDUNITS.c"
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_convert)
{
    dXSARGS;
    if (items != 4)
	croak("Usage: utUnitPtr::convert(from_unit, to_unit, slope, intercept)");
    {
	utUnit *	from_unit;
	utUnit *	to_unit;
	double	slope;
	double	intercept;
	int	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    from_unit = (utUnit *) tmp;
	}
	else
	    croak("from_unit is not of type utUnitPtr");

	if (sv_derived_from(ST(1), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    to_unit = (utUnit *) tmp;
	}
	else
	    croak("to_unit is not of type utUnitPtr");
#line 361 "UDUNITS.xs"
    {
	RETVAL = utConvert(from_unit, to_unit, &slope, &intercept);
    }
#line 600 "UDUNITS.c"
	sv_setnv(ST(2), (double)slope);
	SvSETMAGIC(ST(2));
	sv_setnv(ST(3), (double)intercept);
	SvSETMAGIC(ST(3));
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_valtocal)
{
    dXSARGS;
    if (items != 8)
	croak("Usage: utUnitPtr::valtocal(unit, value, year, month, day, hour, minute, second)");
    {
	utUnit *	unit;
	double	value = (double)SvNV(ST(1));
	int	year;
	int	month;
	int	day;
	int	hour;
	int	minute;
	float	second;
	int	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 381 "UDUNITS.xs"
    {
	RETVAL = utCalendar(value, unit,
			    &year, &month, &day,
			    &hour, &minute, &second);
    }
#line 639 "UDUNITS.c"
	sv_setiv(ST(2), (IV)year);
	SvSETMAGIC(ST(2));
	sv_setiv(ST(3), (IV)month);
	SvSETMAGIC(ST(3));
	sv_setiv(ST(4), (IV)day);
	SvSETMAGIC(ST(4));
	sv_setiv(ST(5), (IV)hour);
	SvSETMAGIC(ST(5));
	sv_setiv(ST(6), (IV)minute);
	SvSETMAGIC(ST(6));
	sv_setnv(ST(7), (double)second);
	SvSETMAGIC(ST(7));
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_caltoval)
{
    dXSARGS;
    if (items != 7)
	croak("Usage: utUnitPtr::caltoval(unit, year, month, day, hour, minute, second)");
    {
	utUnit *	unit;
	int	year = (int)SvIV(ST(1));
	int	month = (int)SvIV(ST(2));
	int	day = (int)SvIV(ST(3));
	int	hour = (int)SvIV(ST(4));
	int	minute = (int)SvIV(ST(5));
	double	second = (double)SvNV(ST(6));
	double	RETVAL;

	if (sv_derived_from(ST(0), "utUnitPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not of type utUnitPtr");
#line 406 "UDUNITS.xs"
    {
	int	status = utInvCalendar(year, month, day,
				       hour, minute, second,
				       unit, &RETVAL);

	if (status == UT_EINVALID)
	    croak("not a unit of time");
	if (status == UT_ENOINIT)
	    croak("units module not initialized");
    }
#line 690 "UDUNITS.c"
	ST(0) = sv_newmortal();
	sv_setnv(ST(0), (double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_utUnitPtr_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: utUnitPtr::DESTROY(unit)");
    {
	utUnit *	unit;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unit = (utUnit *) tmp;
	}
	else
	    croak("unit is not a reference");
#line 424 "UDUNITS.xs"
    {
	free((char*)unit);
    }
#line 715 "UDUNITS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_UDUNITS)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("UDUNITS::constant", XS_UDUNITS_constant, file);
        newXS("UDUNITS::init", XS_UDUNITS_init, file);
        newXS("UDUNITS::term", XS_UDUNITS_term, file);
        newXS("UDUNITS::new", XS_UDUNITS_new, file);
        newXS("UDUNITS::scan", XS_UDUNITS_scan, file);
        newXS("utUnitPtr::istime", XS_utUnitPtr_istime, file);
        newXS("utUnitPtr::hasorigin", XS_utUnitPtr_hasorigin, file);
        newXS("utUnitPtr::clear", XS_utUnitPtr_clear, file);
        newXS("utUnitPtr::dup", XS_utUnitPtr_dup, file);
        newXS("utUnitPtr::shift", XS_utUnitPtr_shift, file);
        newXS("utUnitPtr::scale", XS_utUnitPtr_scale, file);
        newXS("utUnitPtr::multiply", XS_utUnitPtr_multiply, file);
        newXS("utUnitPtr::invert", XS_utUnitPtr_invert, file);
        newXS("utUnitPtr::divide", XS_utUnitPtr_divide, file);
        newXS("utUnitPtr::raise", XS_utUnitPtr_raise, file);
        newXS("utUnitPtr::print", XS_utUnitPtr_print, file);
        newXS("utUnitPtr::convert", XS_utUnitPtr_convert, file);
        newXS("utUnitPtr::valtocal", XS_utUnitPtr_valtocal, file);
        newXS("utUnitPtr::caltoval", XS_utUnitPtr_caltoval, file);
        newXS("utUnitPtr::DESTROY", XS_utUnitPtr_DESTROY, file);
    XSRETURN_YES;
}

